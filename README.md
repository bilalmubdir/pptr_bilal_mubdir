<table align="center">
  <tr>
    <!-- Left: PNG image (30%) -->
    <td width="30%" align="center" valign="middle">
      <img src="docs/figures/misc/pptr_cover.png" height="300">
    </td>
    <!-- Right: SVG banner (70%) -->
    <td width="70%" align="center" valign="middle">
      <img src="banner.svg" height="300">
    </td>
  </tr>
</table>

# Propeller Performance Test Rig Documentation
[![License: CERN-OHL-S](https://img.shields.io/badge/License-CERN--OHL--S-blue.svg)](LICENSE)
  
## ğŸ“˜ Overview
This repository contains openâ€‘source engineering documentation for the Propeller Performance Test Rig, including mechanical drawings, circuit schematics, block diagrams, and specification tables.

<p align="center">
  <img src="docs/figures/misc/pptr_structure_mutliviews.png"/>
</p>
<!-- The materials accompany the research paper: -->
<!-- 
> **"Propeller Performance Test Rig"**  
> *Author: Bilal Mubdir, Research Postgraduate*  
> *Affiliation: University of Leicester*  
-->

All diagrams and documents are provided under the **CERN Open Hardware License â€“ Strongly Reciprocal (CERNâ€‘OHLâ€‘S)**, enabling transparent reuse and modification for academic and engineering purposes. 

## ğŸ“ Repository Structure
```
docs/
â”œâ”€â”€ figures/
â”‚   â”œâ”€â”€ mechanical/     # CAD, enclosure, and mechanical drawings
â”‚   â”œâ”€â”€ electrical/     # Circuit schematics, PCB module diagrams
â”‚   â””â”€â”€ misc/           # other figures and diagrams   
â”œâ”€â”€ scripts/            # Python Remote Client Application and ESP12F/NodeMCU Firmware
â”œâ”€â”€ lib/                # C++ libraries for the ESP12F/NodeMCU Firmware
â””â”€â”€ tables/             # LaTeX tables (specifications, BOM, etc.)
```

## ğŸ“„ Contents
#### **Figures**
- Mechanical drawings (exploded views, dimensions)
- Electrical schematics (DAQ, sensors, control modules)
#### **Tables**
- Technical specifications
#### **Scripts**
- Codes and scripts used for the PPTR system 
#### **Libraries**
- C++ libraries for ESP12F/NodeMCU Firmware


## ğŸ›  Usage
- Access diagrams under `docs/figures/`
- Import tables into your paper from `docs/tables/`


## ğŸ“ Sensor Calibration Instructions (Thrust & Torque Load Cells)
This section provides practical, stepâ€‘byâ€‘step instructions for calibrating the thrust load cell and the left/right torque load cells used in the PPTR measurement system.

### ğŸš€ 1. Thrust Load Cell Calibration
The thrust load cell measures vertical thrust generated by the rotor. To calibrate it:

#### 1.1. Setup
* Mount the PPTR vertically (rotor pointing downward).
* Fix the structure onto a rigid support so it cannot move.
* Attach the calibration weight (standard dead load) to the rotor as shown:
<p align="center" >
  <img src="docs/figures/misc/thrust_calibration.png" height="400"/>
</p>

#### 1.2. Procedure
1) Connect the thrust load cell to its HX711 module.
2) Hang a series of known calibration weights (Loadâ‚›â‚œd) to generate reference thrust forces.
3) For each weight:
    - Record the raw HX711 output.
    - Remove the weight before applying the next one.

#### 1.3. Result
A linear mapping between Raw load cell voltage, and True thrust force (g)should be computed. The **thrust calibration scale factor** then determined from this mapping.

### ğŸŒ€ 2. Torque Load Cell Calibration (Left & Right)
The PPTR includes **two torque load cells**, one on each side of the rotor axis. Calibration is performed with the device in its **normal horizontal operating orientation**.

#### 2.1. Setup
* Install the PPTR horizontally on its base.
* Attach the aluminum torque calibration stripe to the calibration lever.
* This stripe has two symmetric holes on each side of the rotor center, at 50 mm and 100 mm. These holes serve as Calibration Reference Points (CRP).
* The calibration process consists of two steps: tare and measure.
<p align="center" >
  <img src="docs/figures/misc/torque_calibration.png" height="400"/>
</p>

#### 2.2. Tare Both Torque Load Cells - Step (1)
Before taking any calibration measurements:
1) Place the calibration weight (standard dead load) at CRPâ€‘0 (center of the rotor).
2) Perform a tare (zero) on both channels to nullify rotor, brackets, and any sensor bias.

#### 2.3. Take Calibration Measurements - Step (2)
1) Move the calibration weight to one of the CRPs (50 mm or 100 mm).
2) Record raw left and right torque sensor readings.
3) Move the weight to the symmetric CRP on the opposite side.
4) Repeat measurements using multiple Loadâ‚›â‚œd values.

This creates symmetric torque reference conditions on both sides

#### 2.4. Result
A linear mapping between Raw load cell voltage and True torque force (NÂ·m) should be computed. The **Torque calibration scale factor** for each sensor is then determined from its corresponding mapping.

<!----><a name="commandsList"></a>
## ğŸ“¡ Remote Client Command List
The following commands are used to control the PPTR, operate the motor, read sensors, and perform calibration routines from the Remote Client Application.

| Command |  Syntax  | Description | Input Range / Notes |
|--------|----------|-------------|----------------------|
| **Send ESC signal + read sensors** | `CM1,<X>` | Sends ESC control signal *and* reads thrust/torque sensors. | `X = 0â€“180` (Speed â†’ 0â€“Max) |
| **Send ESC signal only** | `CM2,<X>` | Drives the ESC without reading sensors. | `X = 0â€“180` (Speed â†’ 0â€“Max) |
| **Read sensors only** | `CM3` | Reads thrust and torque sensor values. | No input |
| **ESC calibration routine** | `CM4,<X>` | Used to set ESC calibration points. | `X = 0` â†’ min pulse<br>`X = 1` â†’ max pulse |
| **Tare thrust & torque sensors** | `CM5` | Zeros all load cell readings before measurement. | No input |
| **Safe motor shutdown** | `CM6` | Gradually reduces ESC signal to zero. | No input |
| **Safe motor startup** | `CM7,<X>` | Starts motor safely and ramps signal to target value. | `X = 0â€“180` (Speed â†’ 0â€“Max) |
| **System status check** | `CM8` | Reports system status, and safety flags. | No input |

### Notes
- Commands are case-insensitive unless otherwise specified.
- Always run `CM5` (tare) after powering the device or repositioning sensors.
- Calibration (`CM4`) is needed only after replacing ESC or motor hardware.
- Safe start/stop commands (`CM7`, `CM6`) are recommended over issuing raw ESC commands.

## ğŸ§© Using the Code in This Repository

The PPTR software consists of **two components**:

1) **Python Remote Client Application** (runs on your PC/laptop)  
2) **ESP12F / NodeMCU firmware** (C++ for Arduino IDE)

Both code files are located in:

    docs/scripts/

Required libraries for the firmware are provided in:

    docs/lib/

### 1) Remote Client Application (Python)

**File location**

    docs/scripts/remote_client.py

**What it does**
- Connects to the PPTRâ€™s Wiâ€‘Fi hotspot  
- Sends user commands (CM1â€“CM8) to the NodeMCU over UDP  
- Streams and plots realâ€‘time sensor data  
- Logs measurements to a CSV file

**Dependencies**

Install the required Python package:

    pip install matplotlib

(Modules `socket`, `time`, `threading`, `queue`, `sys`, and `select` are part of the standard library.)

**Choose the CSV output filename**

Inside the script, edit the line:

    csv_filename = "sensor_data.csv"

Change the value to set the name of your collected data file.

**How to run**

1. Power the PPTR and wait for its Wiâ€‘Fi hotspot.  
2. Connect your computer to:
   
       SSID: ESP-12F/NodeMCU Access Point name
       PASS: chosen password in ESP-12F/NodeMCU Access Point settings

3. Start the client:

       python remote_client.py

4. The script will start plotting live data and append rows to the CSV file.
5. You can send any command from the [command list](#commandsList), except CM3, as this is used continuously to collect data.
6. To stop, type:

       exit

A final static plot will be shown before the program exits.


### 2) ESP12F / NodeMCU Firmware (C++ for Arduino IDE)

**File location**

    docs/scripts/pptr_firmware.cpp

**What it does**

- Creates a Wiâ€‘Fi Access Point and listens for UDP commands  
- Controls the ESC (safe start/stop + direct control)  
- Reads load cells (HX711), tachometer pulses, and INA226 power sensor  
- Streams sensor data back to the Python client

**Arduino libraries (provided)**

All required libraries are included here:

    docs/lib/

Copy everything inside `docs/lib/` to your Arduino libraries folder, restart the Arduino IDE so it detects the libraries.


**Board support and upload (Arduino IDE)**

1. Install the ESP8266 board support:
   
       Arduino IDE â†’ File â†’ Preferences
       Additional Boards Manager URLs:
       http://arduino.esp8266.com/stable/package_esp8266com_index.json

   Then go to:
   
       Tools â†’ Board â†’ Boards Manager â†’ search â€œESP8266â€ â†’ Install

2. Select the board:

       Tools â†’ Board â†’ NodeMCU 0.9 (ESP-12E Module)

3. Open the firmware file and upload:

       File â†’ Open â†’ docs/scripts/pptr_firmware.cpp
       Upload

After upload, the controller will broadcast its hotspot and accept UDP commands.


## ğŸ“š Citation
If you use this repository in academic work:

```bibtex
@misc{pptrDocumentationBilal2026,
  author       = {Bilal Mubdir, Emmanuel Prempain},
  title        = {Propeller Performance Test Rig Documentation},
  year         = {2026},
  howpublished = {GitHub repository},
  url          = {https://github.com/bilalmubdir/pptr_bilal_mubdir}
}
```
  

## ğŸ¤ Contributing
Contributions are welcome!
Please:

- Follow the folder structure
- Include clear commit messages
- Provide PDFs for all figures
<!-- ## ğŸ§© Maintainers
- Bilal Mubdir
- Research
- Email: bama4@le.ac.uk / bilal.mubdir -->

## License
This project is licensed under the CERN Open Hardware License Version 2 â€“ Strongly Reciprocal (CERNâ€‘OHLâ€‘S).

